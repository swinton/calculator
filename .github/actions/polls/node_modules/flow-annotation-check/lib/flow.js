'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.genForceErrors = exports.genCheckFlowStatus = undefined;

var _core = require('./core');

var _promisified = require('./promisified');

var FLOW_MODE = {
  FLOW_STRICT: 'flow strict',
  FLOW: 'flow',
  FLOW_WEAK: 'flow weak',
  NO_FLOW: 'no flow'
};

function statusFromLines(lines) {
  for (var i = 0, len = lines.length; i < len; i += 1) {
    var words = lines[i].trim().split(' ');
    var nextPosition = words.indexOf('@flow') + 1;
    var nextWord = words[nextPosition];
    if (nextWord === 'strict') {
      return FLOW_MODE.FLOW_STRICT;
    } else if (nextWord === 'weak') {
      return FLOW_MODE.FLOW_WEAK;
    } else if (nextPosition) {
      return FLOW_MODE.FLOW;
    }
  }
  return null;
}

function astToFlowStatus(ast) {
  for (var i = 0; i < 10; i++) {
    var comment = ast.comments[i];
    if (!comment) {
      return FLOW_MODE.NO_FLOW;
    }
    switch (comment.type) {
      case 'Line':
        {
          var status = statusFromLines([comment.value.trim()]);
          if (status) {
            return status;
          }
          break;
        }
      case 'Block':
        {
          var _status = statusFromLines(comment.value.split('\n').map(function (line) {
            return line.trim().replace(/^\*/, '').trim();
          }).filter(Boolean));
          if (_status) {
            return _status;
          }
          break;
        }
      default:
        throw new Error('Unknown comment type ' + comment.type + ' for comment ' + JSON.stringify(comment));
    }
  }
  return FLOW_MODE.NO_FLOW;
}

function genCheckFlowStatus(flowPath, file) {
  var options = { maxBuffer: Infinity };

  return (0, _promisified.exec)(flowPath + ' ast ' + (0, _promisified.escapeShell)(file), options).then(function (_ref) {
    var stdout = _ref.stdout,
        stderr = _ref.stderr;

    if (stderr) {
      throw new Error(stderr);
    }
    return JSON.parse(String(stdout));
  }).then(astToFlowStatus);
}

function genForceErrors(cwd, files, flags) {
  var flowCheck = flags.absolute ? ['check', '--json', '--show-all-errors', cwd] : ['check', '--json', '--show-all-errors', '--strip-root', cwd];
  var options = {
    maxBuffer: Infinity
  };
  var ERROR_STATEMENT = 'const FLOW_ANNOTATION_CHECK_INJECTED_ERROR: string = null;';

  return Promise.resolve(Promise.all(files.map(function (file) {
    return (0, _promisified.append)(file, ERROR_STATEMENT);
  })).then(function () {
    return (0, _promisified.execFile)(flags.flow_path, flowCheck, options).then(function (_ref2) {
      var stdout = _ref2.stdout,
          stderr = _ref2.stderr;
      return JSON.parse(String(stdout));
    }).catch(function (_ref3) {
      var error = _ref3.error,
          stdout = _ref3.stdout,
          stderr = _ref3.stderr;

      try {
        return JSON.parse(String(stdout));
      } catch (e) {
        return {};
      }
    });
  }).then(function (checkResult) {
    return Promise.all(files.map(function (file) {
      return (0, _promisified.truncate)(file, ERROR_STATEMENT);
    })).then(function (_) {
      return (0, _core.unique)((checkResult.errors || []).reduce(function (paths, checkError) {
        return paths.concat(checkError.message.filter(function (message) {
          return message.path;
        }).reduce(function (paths, message) {
          return paths.concat(message.path);
        }, []));
      }, []));
    });
  }));
}

exports.genCheckFlowStatus = genCheckFlowStatus;
exports.genForceErrors = genForceErrors;