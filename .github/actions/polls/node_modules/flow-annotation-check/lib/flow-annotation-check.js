'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.genValidate = exports.genCheckFlowStatus = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _globsToFileList = require('./globsToFileList');

var _globsToFileList2 = _interopRequireDefault(_globsToFileList);

var _isValidFlowStatus = require('./isValidFlowStatus');

var _isValidFlowStatus2 = _interopRequireDefault(_isValidFlowStatus);

var _flow = require('./flow');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function executeSequentially(promiseFactories, defaultValue) {
  var result = Promise.resolve(defaultValue);
  promiseFactories.forEach(function (promiseFactory) {
    result = result.then(promiseFactory);
  });
  return result;
}

function genReport(cwd, flags) {
  var files = (0, _globsToFileList2.default)(cwd, flags.include, flags.exclude, {
    absolute: flags.absolute
  });

  return executeSequentially(files.map(function (file) {
    return function (entries) {
      return (0, _flow.genCheckFlowStatus)(flags.flow_path, file).then(function (status) {
        entries.push({ file: file, status: status });
        return entries;
      });
    };
  }), []);
}

function genFilesWithErrors(cwd, flags) {
  var files = (0, _globsToFileList2.default)(cwd, flags.include, flags.exclude, {
    absolute: flags.absolute
  });

  return (0, _flow.genForceErrors)(cwd, files, flags);
}

function coalesceReports(report, errorReport) {
  return report.map(function (entry) {
    var threwError = errorReport.indexOf(entry.file) >= 0;
    return {
      status: entry.status,
      threwError: threwError,
      isValid: (0, _isValidFlowStatus2.default)(entry.status, threwError),
      file: entry.file
    };
  });
}

function genValidate(cwd, flags) {
  return Promise.all([genReport(cwd, flags), genFilesWithErrors(cwd, flags)]).then(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        report = _ref2[0],
        errorReport = _ref2[1];

    return coalesceReports(report, errorReport);
  });
}

exports.default = genReport;
exports.genCheckFlowStatus = _flow.genCheckFlowStatus;
exports.genValidate = genValidate;