{"version":3,"sources":["../../src/lib/flow.js"],"names":["flowCommandPath","projectDir","tmpDirPath","tmpFilePath","process","env","VERBOSE","path","suffix","dir","cwd","maxBuffer","Infinity","dontReject","res","err","code","console","error","stderr","stdout","statusData","log","JSON","parse","String","unexpectedException","Error","flowVersion","checkFlowStatus","flowCommandTimeout","filename","emptyCoverageData","annotation","expressions","covered_count","uncovered_count","uncovered_locs","escapeFileName","timeout","percent","NaN","isError","flowCoverageError","undefined","flowCoverageException","message","flowCoverageStderr","flowCoverageParsingError","parsedData","collectFlowCoverageForFile","getCoveredPercent","summarizeAnnotations","collectFlowCoverage","Array","prototype","find","require","shim","fileName","replace","total","Math","floor","coverageSummaryData","flowFiles","flowWeakFiles","noFlowFiles","filenames","Object","keys","files","forEach","passed","totalFiles","length","globIncludePatterns","globExcludePatterns","threshold","concurrentFiles","then","waitForCollectedDataFromFiles","Promise","all","drainQueue","now","Date","coverageGeneratedAt","toDateString","toTimeString","annotationSummary","generatedAt","flowStatus","flowAnnotations","cleanupUncoveredLoc","loc","start","source","end","collectCoverageAndGenerateReportForGlob","globIncludePattern","root","pattern","push","data","map"],"mappings":"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","file":"flow.js","sourcesContent":["'use strict';\n\n// @flow\n\nimport minimatch from 'minimatch';\nimport temp from 'temp';\nimport {genCheckFlowStatus} from 'flow-annotation-check';\nimport {exec, glob, writeFile} from './promisified';\n\n// Load the Array.prototype.find polyfill if needed (e.g. nodejs 0.12).\n/* istanbul ignore if  */\nif (!Array.prototype.find) {\n  require('array.prototype.find').shim();\n}\n\n// Escape special characters in file names.\nexport function escapeFileName(fileName: string): string {\n  return fileName.replace(/([\"\\s'$`\\\\])/g, '\\\\$1');\n}\n\n/* eslint-disable camelcase */\nexport function getCoveredPercent(\n  {\n    covered_count, uncovered_count\n  }: {\n    covered_count: number, uncovered_count: number\n  }\n) {\n  const total = covered_count + uncovered_count;\n\n  if (total === 0) {\n    return 100;\n  }\n\n  return Math.floor(covered_count / total * 100);\n}\n/* eslint-disable-line camelcase */\n\n// Definitions and flow types related to checkFlowStatus.\n\nexport type FlowTypeErrorPosition = {\n  offset: number,\n  column: number,\n  line: number\n}\n\nexport type FlowTypeErrorMessage = {\n  type: string,\n  start: number,\n  end: number,\n  line: number,\n  endline: number,\n  path: string,\n  descr: string,\n  context?: string,\n  loc?: {\n    start: FlowTypeErrorPosition,\n    end: FlowTypeErrorPosition,\n    type: string,\n    source: string\n  }\n}\n\nexport type FlowTypeError = {\n  kind: string,\n  level: string,\n  message: Array<FlowTypeErrorMessage>\n}\n\nexport type FlowStatus = {\n  passed: boolean,\n  flowVersion: string,\n  errors: Array<FlowTypeError>\n}\n\nexport async function checkFlowStatus(\n  flowCommandPath: string,\n  projectDir: string,\n  tmpDirPath: ?string\n): Promise<FlowStatus> {\n  let tmpFilePath: ?string;\n\n  if (process.env.VERBOSE && process.env.VERBOSE === 'DUMP_JSON') {\n    tmpFilePath = temp.path({suffix: '.json', dir: tmpDirPath});\n  }\n\n  const res = await exec(`${flowCommandPath} status --json`,\n                         {cwd: projectDir, maxBuffer: Infinity},\n                         {dontReject: true});\n\n  if (res.err && res.err.code !== 2) {\n    if (process.env.VERBOSE) {\n      console.error('Flow status error', res.err, res.stderr, res.stdout);\n    }\n\n    throw res.err;\n  }\n\n  let statusData: ?FlowStatus;\n\n  if (tmpFilePath) {\n    await writeFile(tmpFilePath, res.stdout || '');\n    console.log('Flow status result saved to', tmpFilePath);\n  }\n\n  try {\n    statusData = JSON.parse(String(res.stdout));\n  } catch (err) {\n    const unexpectedException: ?SyntaxError = err;\n\n    // Verify the integrity of the format of the JSON status result.\n    if (unexpectedException) {\n      throw new Error(`Parsing error on Flow status JSON result: ${err}`);\n    }\n  }\n\n  if (statusData && statusData.flowVersion) {\n    return statusData;\n  }\n\n  throw new Error('Invalid Flow status JSON format');\n}\n\n// Definitions and flow types related to collectFlowCoverageForFile.\n\nexport type FlowUncoveredPos = {\n  line: number,\n  column: number,\n  offset: number,\n  source: string\n}\n\nexport type FlowUncoveredLoc = {\n  start: FlowUncoveredPos,\n  end: FlowUncoveredPos\n}\n\nexport type FlowCoverageJSONData = {\n  expressions: {\n    covered_count: number,\n    uncovered_count: number,\n    uncovered_locs: Array<FlowUncoveredLoc>\n  },\n  filename?: string,\n  annotation?: 'no flow' | 'flow weak' | 'flow',\n  percent: number,\n  error?: string,\n  isError?: boolean,\n  flowCoverageError?: ?string,\n  flowCoverageException?: ?string,\n  flowCoverageParsingError?: ?string,\n  flowCoverageStderr?: string|Buffer\n}\n\nexport async function collectFlowCoverageForFile(\n  flowCommandPath: string,\n  flowCommandTimeout: number,\n  projectDir: string,\n  filename: string,\n  tmpDirPath: ?string,\n): Promise<FlowCoverageJSONData> {\n  let tmpFilePath: ?string;\n\n  if (process.env.VERBOSE && process.env.VERBOSE === 'DUMP_JSON') {\n    tmpFilePath = temp.path({suffix: '.json', dir: tmpDirPath});\n  }\n\n  const emptyCoverageData = {\n    filename,\n    annotation: 'no flow',\n    expressions: {\n      covered_count: 0,\n      uncovered_count: 0,\n      uncovered_locs: []\n    }\n  };\n\n  if (process.env.VERBOSE) {\n    console.log(`Collecting coverage data from ${filename} (timeouts in ${flowCommandTimeout})...`);\n  }\n\n  const res = await exec(\n    `${flowCommandPath} coverage --json ${escapeFileName(filename)}`,\n    // NOTE: set a default timeouts and maxButter to Infinity to prevent,\n    // misconfigured projects and source files that should raises errors\n    // or hangs the flow daemon to prevent the coverage reporter to complete\n    // the data collection. (See https://github.com/rpl/flow-coverage-report/pull/4\n    // and https://github.com/rpl/flow-coverage-report/pull/5 for rationale,\n    // thanks to to @mynameiswhm and @ryan953  for their help on hunting down this issue)\n    {cwd: projectDir, timeout: flowCommandTimeout, maxBuffer: Infinity},\n    {dontReject: true});\n\n  if (res.err) {\n    console.error(`ERROR Collecting coverage data from ${filename} `, filename, res.err, res.stderr);\n\n    if (process.env.VERBOSE) {\n      if (tmpFilePath) {\n        await writeFile(tmpFilePath, res.stdout || '');\n      }\n    }\n\n    // TODO: collect errors and put them in a visible place in the\n    // generated report.\n    return {\n      ...emptyCoverageData,\n      percent: NaN,\n      isError: true,\n      flowCoverageError: undefined,\n      flowCoverageException: res.err && res.err.message,\n      flowCoverageStderr: res.stderr,\n      flowCoverageParsingError: undefined\n    };\n  }\n\n  if (process.env.VERBOSE) {\n    console.log(`Collecting coverage data from ${filename} completed.`);\n    if (tmpFilePath) {\n      await writeFile(tmpFilePath, res.stdout || '');\n      console.log(`Saved json dump of collected coverage data from ${filename} to ${tmpFilePath}.`);\n    }\n  }\n\n  let parsedData: ?FlowCoverageJSONData;\n  let flowCoverageParsingError: string;\n\n  if (res.stdout) {\n    try {\n      parsedData = JSON.parse(String(res.stdout));\n    } catch (err) {\n      flowCoverageParsingError = err.message;\n    }\n  }\n\n  if (res.stderr) {\n    try {\n      parsedData = JSON.parse(String(res.stderr));\n      delete res.stderr;\n    } catch (err) {\n    }\n  }\n\n  if (parsedData && !parsedData.error) {\n    parsedData.filename = filename;\n    parsedData.annotation = await genCheckFlowStatus(flowCommandPath, filename);\n    return parsedData;\n  }\n\n  return {\n    ...emptyCoverageData,\n    percent: NaN,\n    isError: true,\n    flowCoverageError: parsedData && parsedData.error,\n    flowCoverageException: undefined,\n    flowCoverageParsingError,\n    flowCoverageStderr: res.stderr\n  };\n}\n\n// Definition and flow types related to collectForCoverage.\n\ntype FlowAnnotationSummary = {\n  passed: boolean,\n  flowFiles: number,\n  flowWeakFiles: number,\n  noFlowFiles: number,\n  totalFiles: number,\n};\n\nexport type FlowCoverageSummaryData = {\n  covered_count: number,\n  uncovered_count: number,\n  percent: number,\n  threshold: number,\n  generatedAt: string,\n  flowStatus: FlowStatus,\n  flowAnnotations: FlowAnnotationSummary,\n  globIncludePatterns: Array<string>,\n  globExcludePatterns: Array<string>,\n  concurrentFiles: number,\n  files: {\n    [key: string]: FlowCoverageJSONData\n  }\n}\n\nexport function summarizeAnnotations(\n  coverageSummaryData: FlowCoverageSummaryData\n): FlowAnnotationSummary {\n  let flowFiles = 0;\n  let flowWeakFiles = 0;\n  let noFlowFiles = 0;\n\n  const filenames = Object.keys(coverageSummaryData.files);\n\n  filenames.forEach(filename => {\n    switch (coverageSummaryData.files[filename].annotation) {\n      case 'flow':\n        flowFiles += 1;\n        break;\n      case 'flow weak':\n        flowWeakFiles += 1;\n        break;\n      case 'no flow':\n        noFlowFiles += 1;\n        break;\n      default:\n        throw new Error(`Unexpected missing flow annotation on ${filename}`);\n    }\n  });\n\n  return {\n    passed: (flowWeakFiles + noFlowFiles) === 0,\n    flowFiles,\n    flowWeakFiles,\n    noFlowFiles,\n    totalFiles: filenames.length\n  };\n}\n\nexport function collectFlowCoverage(\n  flowCommandPath: string,\n  flowCommandTimeout: number,\n  projectDir: string,\n  globIncludePatterns: Array<string>,\n  globExcludePatterns: Array<string>,\n  threshold: number,\n  concurrentFiles: number,\n  tmpDirPath: ?string,\n): Promise<FlowCoverageSummaryData> {\n  return checkFlowStatus(flowCommandPath, projectDir, tmpDirPath).then(flowStatus => {\n    const now = new Date();\n    const coverageGeneratedAt = now.toDateString() + ' ' + now.toTimeString();\n\n    const annotationSummary = {\n      passed: false,\n      flowFiles: 0,\n      flowWeakFiles: 0,\n      noFlowFiles: 0,\n      totalFiles: 0\n    };\n\n    const coverageSummaryData: FlowCoverageSummaryData = {\n      threshold,\n      covered_count: 0, uncovered_count: 0, // eslint-disable-line camelcase\n      percent: 0,\n      generatedAt: coverageGeneratedAt,\n      flowStatus,\n      flowAnnotations: annotationSummary,\n      files: {},\n      globIncludePatterns,\n      globExcludePatterns,\n      concurrentFiles\n    };\n\n    // Remove the source attribute from all ucovered_locs entry.\n    function cleanupUncoveredLoc(loc) {\n      delete loc.start.source;\n      delete loc.end.source;\n      return loc;\n    }\n\n    let waitForCollectedDataFromFiles = [];\n\n    async function drainQueue() {\n      if (process.env.VERBOSE) {\n        console.log(`Wait for ${waitForCollectedDataFromFiles.length} queued files.`);\n      }\n      // Wait the queued files.\n      await Promise.all(waitForCollectedDataFromFiles);\n      // Empty the collected Data From files queue.\n      waitForCollectedDataFromFiles = [];\n    }\n\n    function collectCoverageAndGenerateReportForGlob(globIncludePattern) {\n      return glob(globIncludePattern, {cwd: projectDir, root: projectDir})\n        .then(async files => {\n          for (const filename of files) {\n            // Skip files that match any of the exclude patterns.\n            if (globExcludePatterns.find(pattern => minimatch(filename, pattern)) !== undefined) {\n              if (process.env.VERBOSE) {\n                console.log(`Skip ${filename}, matched excluded pattern.`);\n              }\n              continue;\n            }\n\n            if (process.env.VERBOSE) {\n              console.log(`Queue ${filename} flow coverage data collection`);\n            }\n\n            waitForCollectedDataFromFiles.push(collectFlowCoverageForFile(\n              flowCommandPath, flowCommandTimeout, projectDir, filename, tmpDirPath\n            ).then(data => {\n              /* eslint-disable camelcase */\n              coverageSummaryData.covered_count += data.expressions.covered_count;\n              coverageSummaryData.uncovered_count += data.expressions.uncovered_count;\n              data.percent = getCoveredPercent(data.expressions);\n\n              if (!data.filename) {\n                throw new Error('Unxepected missing filename from collected coverage data');\n              }\n\n              coverageSummaryData.files[data.filename] = data;\n\n              data.expressions.uncovered_locs =\n                data.expressions.uncovered_locs.map(cleanupUncoveredLoc);\n              /* eslint-enable camelcase */\n            }));\n\n            // If we have collected at least `concurrentFiles` number of files,\n            // wait the queue to be drained.\n            if (waitForCollectedDataFromFiles.length >= concurrentFiles) {\n              await drainQueue(); // eslint-disable-line no-await-in-loop\n            }\n          }\n\n          // Wait for any remaining queued file.\n          if (waitForCollectedDataFromFiles.length > 0) {\n            await drainQueue();\n          }\n\n          return files;\n        });\n    }\n\n    return Promise\n      .all(globIncludePatterns.map(collectCoverageAndGenerateReportForGlob))\n      .then(() => {\n        coverageSummaryData.percent = getCoveredPercent(coverageSummaryData);\n        coverageSummaryData.flowAnnotations = summarizeAnnotations(\n          coverageSummaryData\n        );\n\n        return coverageSummaryData;\n      });\n  });\n}\n"]}